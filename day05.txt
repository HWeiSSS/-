回顾
1.epoll模型 : 效率高,触发方式更多
2.本地套接字 AF_UNIX 本地两个进程间的消息通信
3.多任务编程 并行 
            并发
            进程和线程
4.多进程编程
    时间片 PCB PID 父子进程 优先级  进程特征
    进程状态 : 就绪态 运行态 等待态
5.ps -aux   ps -ajx   pstree   top   nice
6.os.fork()
7.os.getpid()  os.getppid()
  os._exit()   sys.exit()
8.孤儿进程和僵尸进程
**************************************************************
如何避免僵尸进程产生
    *处理子进程退出状态
        pid,status = os.wait()
        功能 : 在父进程中阻塞等待处理子进程退出
        返回值 : PID 退出的子进程的PID号
                status 获取子进程的退出状态
    *让父进程先退出
        功能 : 让父进程中等待处理的的子进程UI出
        蚕食 : pid    -1 表示等待任意子进程瑞出
                     >0 表示等待对应PID号的子进程退出
        1.父进程创建子进程等待子进程退出
        2.子进程创建二季子进程后立即退出
        3.二级子进程称为孤儿,和原来的父进程各自执行事件



搭建网络连接--> 创建多进程--> 每个进程功能编写--> 项目功能模块编写

进入聊天室
客户端 : 输入姓名 将信息发给服务端(L,name)
        等待服务端回复 根据回复判断是否登陆成功
服务端 : 接收请求信息 判断请求类型  判断用户名是否存在
        如果存在回复不能登录 如果不存在回复可以登录并插入到数据结构
        发送通知给其他用户

multiprocessing 模块创建过程
1.需要将要执行的事情封装为函数
2.使用multiprocessing模块中Process类创建进程对象
3.通过对象属性升值和Process的初始化函数对进程进行设置,绑定要执行的函数
4.启动进程,会自动执行进程绑定的函数
5.完成进程的回收

Process()
功能 : 创建进程对象
参数 : name 进程名称 Process-1
      target 绑定函数
      args 元祖 给target函数按照位置传参
      kwargs 字典 给target按照键值对传参
p.start()
功能: 启动进程
* target函数会自动执行,此时进程真正被创建
p.join([timeout])
功能 : 阻塞等待回收子进程
参数 : 超时时间

* 使用multiprocessing创建子进程,同样子进程复制父进程全部代码段,父子进程各自执行互不影响,父子进程有各自的运行空间

* 如果不使用join回收子进程则子进程退出后会成为僵尸进程
* 使用multiprocessing创建子进程往往父进程只是用来创建进程回收机进程